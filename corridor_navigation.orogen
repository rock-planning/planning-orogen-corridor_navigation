name "corridor_navigation"
version "0.1"

using_library "vfh_star"
#using_library "asguard"
using_library 'corridor_navigation'
using_library 'velodyne_lidar'
import_types_from "base"
import_types_from "corridor_planner"
import_types_from "envire"

import_types_from "vfh_star/Types.h"
import_types_from "vfh_star/TreeSearch.h"
import_types_from "vfh_star/DebugTypes.h"
import_types_from "corridor_navigation/VFHFollowingConf.hpp"
import_types_from "corridor_navigation/VFHServoingConf.hpp"
import_types_from "corridor_navigation/VFHStarDebugData.hpp"
import_types_from "corridorNavigationTypes.hpp"
import_types_from "velodyne_lidar/MultilevelLaserScan.h"

typekit.opaque_type '/vfh_star/Tree', 'wrappers/vfh_star/Tree'

task_context "ServoingTask" do
    input_port("scan_samples", "base/samples/LaserScan").
	needs_reliable_connection.
        doc "LaserScann of front Scanner"

    input_port("scan_samples_back", "base/samples/LaserScan").
	needs_reliable_connection.
        doc "Optional LaserScann of rear scanner"

    input_port("velodyne_scans", "velodyne_lidar::MultilevelLaserScan").
	needs_reliable_connection.
        doc 'Optional velodyne scans'

    input_port('heading', 'double').
	doc 'differential heading in NWU, where the robot should drive'

    input_port('absolute_heading', 'double').
	doc 'heading in NWU, where the robot should drive'

    input_port('do_planning', 'bool').
        doc 'setting this value to false disables the planning. Pretty usefull for traversability parameter tuning'

    output_port("segmented", "bool").
	doc "debug port for log replay"

    output_port("trajectory", "std::vector</base/Trajectory>")

    output_port("gridDump", "vfh_star/GridDump")

    output_port("vfhDebug", "corridor_navigation/VFHStarDebugData")

    output_port('debugVfhTree', '/vfh_star/Tree').
        doc 'the resulting internal search tree'

    output_port('debug_laser_frame', '/base/samples/RigidBodyState').
	    doc 'debug frame. This is the frame of the laser scan in respect to the map.'
	   
    output_port('debug_heading_frame', '/base/samples/RigidBodyState').
	    doc 'Debug frame describing the heading orientation'

    output_port('debug_sweep_status','int').
        doc 'Current tracked sweep angle'	   

    output_port('count_no_trajectory','int').
        doc 'Counter of the number of times in a row that no trajectory cannot be found even if the searching area is not unknown'	   

    output_port('count_unknown_trajectory','int').
        doc 'Counter of the number of times in a row that no trajectory cannot be found beacuase of passing through unknown area'	   
    
    output_port('is_planning', 'bool').
        doc 'True when the robot is planning. If false the robot is only building the local map.'

    operation('setMap').
	argument('map', 'std/vector</envire/BinaryEvent>').
	argument('mapId', 'std/string').
	argument('mapPose', '/base/samples/RigidBodyState').
	returns('bool')
	doc("Sets an apriori map of the environment of the robot. This function must be be called prior to starting the component.")

    operation('attemptPlanning').
	argument('heading', 'double').
	returns('bool')
	doc("Tries to plan in the given heading. Only if a trajectory is found true is returned.")

    ##########################
    # transformer parameters
    ##########################

    transformer do
	transformation("body_center", "body")
	transformation("body_center", "odometry")
	transformation("laser", "body_center")
        transformation("laser_back", "body_center")
        transformation("velodyne", "body_center")
	align_port('scan_samples', 0.025)
	align_port('scan_samples_back', 0.025)
	align_port('velodyne_scans', 0.08)

	max_latency(0.1)
    end

    property('search_conf', '/vfh_star/TreeSearchConf').
        doc('Parametrization of the search')
    property('cost_conf', '/corridor_navigation/VFHServoingConf').
        doc('Parametrization of the cost function')
    property('search_horizon', 'double').
        doc 'the search horizon, in meters'
    property('fail_count',  'int32_t', 1).
    	doc('The number of times in a row where no trajectorie could be computed, that makes the task fail')
    property('unknown_retry_count',  'int32_t', 2).
    	doc('In case the trajectorie goes through unknown terrain, it is cut. This parameter defines how often the task will wait for a sensor sweep to complete before failing.')
    property('x_forward', 'bool', true).
        doc('for backward compatibility only. Set to false to use the Y-forward convention. Rock uses a X-forward convention')
    property('allowBackwardsDriving', 'bool', true).
        doc('This property specifies if the robot is allowed to drive backwards')
    property('height_to_ground', 'double', 0).
        doc 'the distance between the body frame and the ground'
    property('front_shadow_distance','double',0.0).
        doc 'the region in front of the laser the laser cannot scan. (if <= 0 it will be computed from the tilt angle)'
    property('entry_window_size', 'int', 30).
        doc 'Maximum number of measures that are taken into accound when '+
          'constructing a cel of the occupancy grid.'
    property('entry_height_conf', 'int', 0).
        doc 'Method for constructing each cell height from all the perceived' +
          ' measures. Codes: 0 - mean, 1 - mean+0.5*std, 2 - median.'
    property('replanning_delay', 'double', 10).
        doc 'Minimal time in seconds to wait until another replanning is allowed'
    property('min_trajectory_lenght', 'double', 0.2).
        doc('Minimal length of the output trajectory. The planned trajectory gets cut if it goes through unknown terrain.').
        doc("If the resulting trjacetory length is smaler than this parameter an trajectory_through_unknown error will be generated")
    property('allow_planning', 'bool', true).
        doc 'setting this value to false disables the planning. Pretty usefull for traversability parameter tuning'
    property('allow_exception', 'bool', true).
        doc 'setting this value to false disables the exception states in case the planner did not find a solution. Pretty usefull for parameter tuning on log data'

    ## velodyne filter parameter
    property('velodyne_maximum_angle_to_neighbor', 'double', 2.53).
        doc('valid neigbors have an angle not greater than this value.').
        doc('the angle is always defined from the origin to the more distant point.')
    property('velodyne_minimum_valid_neighbors', 'int', 2).
        doc('minimum amount of valid neigbors')
        

    exception_states :no_solution, :trajectory_through_unknown

    needs_configuration
    port_driven 'scan_samples'
    port_driven 'do_planning'
    worstcase_processing_time 0.3	
end

task_context "FollowingTask" do
    doc "This task makes the robot cross a given corridor structure, from its beginning to its end"

    property('search_conf',  'vfh_star::TreeSearchConf')
    property('cost_conf',    'corridor_navigation::VFHFollowingConf')
    property('search_horizon', 'double').
        doc 'the search horizon, in meters'

    input_port('problem', '/corridor_navigation/CorridorFollowingProblem').
        doc 'the corridor following problem'

    input_port('pose_samples', '/base/samples/RigidBodyState').
        doc 'the current robot pose'

    output_port('trajectory', 'std::vector</base/Trajectory>').
        doc 'the generated trajectory'

    output_port('debugVfhTree', '/vfh_star/Tree').
        doc 'the resulting internal search tree'

    output_port('debug', '/corridor_navigation/FollowingDebug').
        doc 'the resulting state of the planner'

    exception_states :DEAD_END, :NO_VIABLE_PATH
    port_driven 'pose_samples'
end

task_context "PoseAlignmentTask" do
    input_port('target_pose', '/base/Pose').
        doc 'the target pose after final alignment'

    output_port('motion_commands', '/base/MotionCommand2D')
        doc 'motion commands to perform the alignment'

    transformer do
        transformation('body','world')
        transformation("body", "odometry")
        max_latency(0.1)
    end

    property('turn_speed',  'double', 0.0)
    property('forward_speed',  'double', 0.0)
    property('min_distance_to_target',  'double', 0.0)
        .doc("If the robot is less than this distance away from the target position, it will assume it reached it")
    property('min_alginment_angle',  'double', 0.0)
        .doc("The precision of the alignement the robot will try to achive")
    property('retry_distance',  'double', 0.0)
        .doc("If the robot is more than the retry distance away from the target, it will
              realign to the target position and try driving there again")

    exception_states :TOO_FAR_FROM_TARGET

    periodic 0.1
end

task_context "TestTask" do
    property('test_conf', 'corridor_navigation::TestConf')
    property('search_conf',  'vfh_star::TreeSearchConf')
    property('cost_conf',    'vfh_star::VFHStarConf')
    property('initial_pose', 'base/Pose')
    property('search_horizon', 'double', 2.0).
        doc 'the search horizon, in meters'

    output_port('trajectory', '/base/geometry/Spline<3>')
    output_port('search_tree', '/vfh_star/Tree')
end

deployment "corridorNavigationTest" do
    task('corridor_servoing', "corridor_navigation::ServoingTask").
	triggered
    task('corridor_following', "corridor_navigation::FollowingTask").
	triggered
    task('vfh_search_test', "corridor_navigation::TestTask").
	triggered

    add_default_logger
end

